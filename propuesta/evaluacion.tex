%! TEX root = ../main.tex
\section{Evaluación en tiempo de ejecución}

Las acciones realizadas por los usuarios dentro de la aplicación son evaluadas
para determinar si realizo o no el procedimiento de manera correcta y así
brindarle información al usuario sobre su rendimiento.

En esta sección se explica como son evaluados las acciones de los usuarios para
los diferentes procedimientos simulados.

\subsection{Extracción de muestras de sangre}

Para la evaluación de las acciones del usuario en este procedimiento se utilizo
un motor de reglas denominado \enquote{Acciones condicionadas por eventos}. A
continuación se explica en detalle cada aspecto relacionado tanto al motor como
a la forma de evaluación del rendimiento del usuario.

\subsubsection{Acciones condicionadas por eventos}

Un evento es la ocurrencia de un hecho en particular, y son identificados por un
nombre y un conjunto de parámetros, por ejemplo, cuando un evento es cuando el
enfermero inserta una Jeringa, el nombre de este evento es
\enquote{jeringa}.inserted, y sus parámetros podrían ser el lugar y el tiempo
de la inserción, así, la influencia del estudiante en la simulación es una
sucesión de eventos.

Por cada acción que realiza el usuario dentro de la simulación, existe un evento
relacionado, por consiguiente, es razonable estudiar algunos eventos para
determinar si los pasos realizados corresponden con los deseados. 

Para determinar si una sucesión de eventos es la correcta, se definen reglas,
una regla es una asociación de una condición y una acción, la condición define
si el entorno es el adecuado para realizar una acción, la cual es un
procedimiento que realiza la lógica deseada.

Las \gls{eca} son aquellas que son activadas una vez que se cumplen determinados
eventos\cite{bailey2004event}. En las bases de datos relacionales, son conocidos
como triggers, es decir, una base de datos relacional (u orientada a objetos) es
un motor de reglas \gls{eca}\cite{bailey2004event}\cite{behrends2006combining}.

Las mismas pueden ser utilizadas para notificar que un determinado conjunto de
eventos ha ocurrido\cite{bailey2004event}, así como servir para almacenar
información acerca de la utilización de un determinado recurso.


\paragraph{Motivación}

Las reglas del tipo \gls{eca} permiten reaccionar a determinados eventos, en
forma de una única regla, la cual facilita la declaración de las
mismas\cite{bailey2004event}.

Son principalmente útiles para analizar el comportamiento en tiempo real de un
sistema en una forma
reactiva\cite{bailey2004event}\cite{de2001eca}\cite{bailey2002analysis}, esta
característica esta impulsada principalmente por que son ejecutadas después de
la ocurrencia de un evento, y el entorno no es modificado, pudiendo así acceder
al mismo entorno que el qué lanzo el evento.

Definir si las acciones de un usuario son correctas utilizando un motor
\gls{eca} es sencillo desde el punto de vista que sólo se deben definir un
conjunto de acciones que se deben realizar, y agregar una acción que verifica si
los pasos realizados fueron los correctos.

\paragraph{Declaración}

Una \gls{eca}, se define como\cite{bailey2004event}\cite{behrends2006combining}:

\begin{center}
	 Cuando ocurren una serie de \emph{eventos}, y se cumple una
	 \emph{condición}, entonces realizar una \emph{Acción}.
\end{center}

Los \emph{eventos} determinan cuando una regla debe ser activada, los mismos se
dividen en dos categorías\cite{behrends2006combining}, primitivos y compuestos,
los primeros son detectables, por ejemplo, cuando se inserta una jeringa, y los
compuestos, son la combinación de uno o más
primitivos\cite{bailey2004event}\cite{behrends2006combining}. Los eventos
compuestos, se unen mediante:
\begin{enumerate*}[label=\itshape\alph*\upshape)]
\item conjunción (\emph{y}),
\item disyunción (\emph{o}), y
\item secuencia (\emph{entonces}).
\end{enumerate*}
Sin embargo, no siempre son necesarios todas las posibles combinaciones, y las
combinaciones sencillas son más fáciles de optimizar y
probar\cite{bailey2004event}.

La \emph{condición} de una regla determina si el entorno es el necesario para que la
regla sea activada, en esta condición el entorno que lanzó el evento esta
disponible.

La \emph{acción} a ejecutar describe la lógica que debe ser ejecutada cuando se han
lanzado los eventos y la condición de la regla se ha cumplido.

\paragraph{Dependencia entre reglas}

Las reglas pueden depender de otras reglas, lo cual se puede ver como que la
finalización de una regla es un evento que otra regla espera para poder ser
activada.

Las reglas pueden agregar información a un contexto compartido por todas las
reglas, de esta manera, se puede pasar parámetros entre distintas reglas, por
ejemplo, la regla \emph{Retirar Torniquete}, depende de la regla \emph{Insertar
Torniquete}, pero debe responder solamente al torniquete que ha activado
la regla de inserción, es decir, el usuario puede extraer varios torniquetes, y
la regla no debe activarse, hasta que se extraiga el torniquete que activo la
primer regla.

Así, la regla \emph{Retirar Torniquete} depende de la regla \emph{Insertar
Torniquete}, y esta relación entre reglas, se da en dos
formas\cite{bailey2004event}:

\begin{itemize}
\item  \emph{Dependencia fuerte:} la regla \emph{Retirar Torniquete} solamente podrá
	ser elegida para ser lanzada cuando la regla \emph{Insertar Torniquete}
	haya sido cumplida.
\item  \emph{Dependencia de contexto}: la regla \emph{Retirar Torniquete} no se
	activará cuando los eventos a los que escucha se terminen, sino cuando
	los eventos a los que escucha sean lanzados con los parámetros adecuados
	(se extraiga el torniquete que lanzo la regla de inserción).
\end{itemize}

\paragraph{Representación}

La definición de las reglas se realiza de la siguiente forma;
\begin{algorithm}[H]
\caption{Creación de regla de verificación de calzado de guantes}
\label{alg:rule:guante}
\lstset{style=sharpc}
\begin{lstlisting}
Rule.New("Regla de verificacion de calzado de guantes").
     When("enfermero.guantes.calzar").
     Then(e => e.Patient.ManosLimpias()).
\end{lstlisting}
\end{algorithm}
%TODO agregar indice de algoritmos

La regla anterior controla que el estudiante ha realizado la acción ``Calzarse
los guantes'', y en ese momento tenga las manos limpias, la variable \emph{e},
es el entorno, y a través de la propiedad \emph{Patient} obtiene el estado del
paciente en ese momento.

\paragraph{Modelo de ejecución}

Para ejecutar un motor de reglas del tipo \gls{eca}, se debe tener en cuenta
principalmente dos factores, 
\begin{enumerate*}[label=\itshape\alph*\upshape)]
\item  Como se verifica el cumplimiento de cada regla, y, 
\item  Que ocurre cuando varias reglas son lanzadas al mismo tiempo
\end{enumerate*}.

Para ambos casos se puede tomar un enfoque \emph{inmediato}, es decir que
inmediatamente cuando se lanza un evento, o se cumple una condición, se ejecuta
la regla. Además existen otros dos modos de ejecución, \emph{deferida}, y
\emph{desacoplada}, en la primera, se espera hasta que el lanzador del evento
culmine su trabajo, y luego se ejecuta la regla, pero en la misma unidad de
trabajo, mientras que en la ejecución desacoplada, se encolan los trabajos y
otro hilo es el encargado de ejecutar las reglas. Estos modos están inspirados
en las bases de datos relacionales, el deferido se ejecuta en la misma
transacción, y el desacoplado, inmediatamente después de que la transacción
termine\cite{bailey2004event}.

La propuesta implementada, utiliza una ejecución inmediata, principalmente por
la sencillez de las reglas, es decir, las reglas no realizar un proceso complejo,
solamente controlan el estado del entorno y lo validan.

Además, la ejecución inmediata es importante por que el entorno no sufre
modificaciones entre el evento lanzado y la ejecución de la regla, según
\cite{bailey2004event}, este es el factor más importante para determinar el tipo
de ejecución deseado.



\paragraph{Estados de una regla}

Una regla puede estar en uno de los siguientes estados:

\begin{description}
\item[BEGIN] Es una regla que recién fue creada, no realiza ninguna
	acción.
\item[WAITING\_FOR\_RULE] Es un estado en el que esta esperando que otras reglas
	sean lanzadas. En este estado, es un suscriptor de las reglas por la que
	espera, y no forma parte del ciclo de ejecución del motor de reglas.
\item[WAITING\_FOR\_EVENT] Es un estado en el que esta escuchando a que sean
	lanzados los eventos a los que escucha, este es el estado principal. En
	este estado, es un suscriptor de los eventos por los que espera, y no
	forma parte del ciclo de ejecución del motor de reglas. Se diferencia
	del estado anterior, en que los eventos escuchados pueden ser lanzados
	por cualquier objeto del entorno, no necesariamente una regla.
\item[WAITING\_FOR\_CONDITION] La regla ya no espera por ningún evento y las
	reglas de las que depende ya han sido lanzadas, se verifica cada cierto
	tiempo si el entorno cumple con una condición definida. 
\item[FINISH] La regla ha sido lanzada, con un resultado no determinado, se pudo
	haber cumplido, como no, es el estado final de una regla. Cuando una
	regla llega a este estado, se lanza su evento de finalización.
\end{description}

Una regla puede estar en solo un estado, y solamente se permite que el estado
avance, desde \emph{BEGIN} hasta \emph{FINISH}.


\paragraph{Ciclo de vida}

Cuando una regla es definida, y insertada al motor de reglas, inmediatamente
pasa al estado \emph{BEGIN}, luego se verifica si la misma depende de otras
reglas, sí este es el caso, pasa al estado \emph{WAITING\_FOR\_RULE} y escucha a
los eventos de finalización de las reglas anteriores.

Una vez que las reglas anteriores han sido finalizadas, la regla pasa al estado
\emph{WAITING\_FOR\_EVENT} sí deben escuchar por algún evento, en caso contrario
pasan al estado \emph{WAITING\_FOR\_CONDITION}.

Una vez que la regla está en estado \emph{WAITING\_FOR\_CONDITION}, pasa a un
motor que ejecuta su condición cada cierto tiempo, si la condición se cumple, la
regla se ejecuta, y la misma pasa a estado \emph{FINISH}, momento en el cual
notifica a las reglas que dependen de ella que ha sido lanzada.

Una vez que la regla esta en estado \emph{FINISH}, la misma sale del esquema de
ejecución, y solo esta disponible para obtener resultados.

Según el ejemplo de la regla definida en el código\ref{alg:rule:guante}, la
regla al terminar de ser construida pasa a estado \emph{BEGIN}, al no depender
de otras reglas, pasa inmediatamente al estado \emph{WAITING\_FOR\_EVENT},
cuando es lanzado el evento, la regla ejecuta la acción y pasa al estado
\emph{FINISH}.

\paragraph{Motor de ejecución}

Un motor de reglas \gls{eca}, requiere de un proceso que evalúe constantemente
las reglas para verificar si las mismas deben ser lanzadas o
no\cite{bailey2004event}\cite{galton2002two}, este motor puede utilizar el
algoritmo de RETE\cite{de2001eca} para realizar esta verificación, en la
propuesta presentada, la cantidad de reglas definidas, y la no dependencia
circular entre ellas, hace innecesario la implementación de tal
algoritmo\cite{de2001eca}. 

El motor de reglas actúa sobre aquellas reglas en estado
\emph{WAITING\_FOR\_CONDITION} e invoca al procedimiento que se encarga de
validar si la regla puede ser activada (el procedimiento es único por cada
regla), si el mismo determina que la regla puede ser lanzada, el motor ejecuta
la acción de la regla y modifica el estado de la regla a \emph{FINISH}.


\subsubsection{Definición de reglas}

La reglas del procedimiento de extracción de sangre fueron definidas de acuerdo
a los pasos requeridos según el protocolo del procedimiento y al orden en el que
son requeridos. Es decir, cada paso del protocolo tiene asociado una regla
dentro del motor que lo representa y las condiciones asociadas a cada regla
están determinadas por el orden en que deben realizarse dentro del protocolo.

Cada regla tiene una o mas condiciones que deben ser cumplidas para que un paso
del protocolo realizado se considere correcto.

\subsubsection{Retroalimentación y puntuación final}
\label{sec:puntuacion_hemocultivo}

Cada regla tiene asociado un peso, de acuerdo a la dificultad de realizar el
paso, este peso es utilizado al final de la partida para darle una puntuación al
usuario acerca de su rendimiento en la partida.

Además, un regla puede quedar en uno de diferentes estados al final de la
partida como se mostró anteriormente, cada uno de esos estados posee un
significado en el contexto del procedimiento y por lo tanto tiene información
asociada para que al final de la partida se muestre una retroalimentación
correcta al usuario por paso.

\subsection{Valoración de la escala de Glasgow}
\label{sec:puntuacion_glasgow}

Para la evaluación del rendimiento del usuario en el momento de llevar a cabo el
procedimiento de valoración de la escala de Glasgow se tuvo un enfoque
completamente diferente al del procedimiento de extracción de muestras de sangre
debido a la naturaleza propia del procedimiento. 

Como se explico anteriormente, el paciente puede estar en ciertos estados
específicos dentro de la escala, y además dentro de cada estado reacciona de un
forma en particular por lo tanto, al inicio de la partida un componente interno
de la aplicación selecciona de forma aleatoria un estado para el paciente, de
forma tal que cada vez que una partida sea jugada no se repitan los estados de
forma seguida.

El estado aleatorio del paciente es guardado en una variable que no es
modificada hasta que se reinicie la partida. Al final de la partida, la
aplicación pide al usuario que valore el estado del paciente que le fue
presentado, una vez que el usuario confirme su respuesta la aplicación la
compara con el estado guardado y de esta forma puede informar al usuario acerca
de su rendimiento en el diagnostico.

Además, cada posible respuesta dada por el usuario contiene información
relacionada al contexto del procedimiento y a la situación actual presentada la
cual es utilizada como retroalimentación al final de la partida. La puntuación
final dada depende de la cantidad de valoraciones correctas dadas por el usuario
para la respuesta verbal, motora, ocular y nivel de gravedad del paciente.









